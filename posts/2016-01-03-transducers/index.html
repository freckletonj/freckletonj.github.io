<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Transducers | The Gentleman Programmer</title>
        <link rel="shortcut icon" href="../../img/favicon.ico" />

        <!------ Bootstrap ----->
        
        <!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
             rel="stylesheet"
             integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
             crossorigin="anonymous">
             <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
             integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
             crossorigin="anonymous"></script>
           -->
        
        <!-- theme from: https://bootswatch.com/ -->
        <link rel="stylesheet" type="text/css" href="../../css/bootstrap.css" />

        
        <!------ FontAwesome ----->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

        <!-- My CSS -->
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />

        <!-- Google Analytics -->
        <script>
         (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

         ga('create', 'UA-91639900-1', 'auto');
         ga('send', 'pageview');

        </script>
    </head>
    
    <body>

        <div class="banner"></div>
<br />
<div class="container">
    <div class="row">
        <div class="col-xs-8 col-xs-offset-2">

            <!-- NOTE: edit colors directly in the svg's style tag -->
            <a href="../../">
                <img class="beard" type="image/svg+xml" src="../../img/beard.svg" />
            </a>
        </div>
    </div>
</div>
<br />




        <div class="container">
            <div class="row">
                <div class="col-xs-8 col-xs-offset-2">
                    <div id="content">
                        <h1 class="text-center">Transducers</h1>
<div class="info text-center">
    Posted on January  3, 2016
    
        by Josh
    
</div>
<hr />
<p><strong>TL;DR</strong> They’re not tough. Play around with the following functions in a repl, and you’ll master this super useful pattern:</p>
<style type="text/css">
    table {
        width:100%;
    }
</style>
<div class="row">
<div class="col-xs-8 col-xs-offset-2">
<table>
<tbody>
<tr class="odd">
<td><strong>reducing fns</strong>:</td>
<td align="right"><code>[conj str]</code></td>
</tr>
<tr class="even">
<td><strong>xform fns</strong>:</td>
<td align="right"><code>[(map inc) (filter even?)]</code></td>
</tr>
<tr class="odd">
<td><strong>appliers</strong>:</td>
<td align="right"><code>[transduce eduction]</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<h1 id="why-transducers-composition.">Why Transducers? Composition.</h1>
<p>A good solution to a problem is one that you can easily pair with other solutions, and blissfully ignore extraneous details, such as what specifically the current solution is getting applied to.</p>
<p>This is, of course, composition. And different shapes of solutions compose in different ways. For example, plain functions compose with clojure’s <code>(comp ...)</code>.</p>
<p>ex: <code>(comp (partial + 1) (partial * 2))</code> returns a function that now acts like <code>(fn [x] (-&gt; x (* 2) (+ 1)))</code></p>
<p>Transducers are a pattern for <code>comp</code>ing modifications that you want to make to a reducing function.</p>
<h1 id="reducing-functions-or-rfs">Reducing Functions (or <code>rf</code>s)</h1>
<p>You’ll find over your career that a lot of solutions you write can reduce to something that looks like this:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">fn</span> reducing-fn
  [accumulator piece] ...) <span class="co">;; =&gt; new-accumulator</span></code></pre></div>
<p>Examples of reducing fns:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span>] <span class="dv">3</span>) <span class="co">;; =&gt; [1 2 3]</span>
(<span class="kw">str</span> <span class="st">&quot;accumulating string, &quot;</span> <span class="st">&quot;new piece&quot;</span>) <span class="co">;; =&gt; &quot;accumulating string, new piece&quot;</span></code></pre></div>
<p>Note: <code>reduce</code> is called <code>fold</code> in haskell, and you’ll see various flavors of <code>fold</code>, but which stay close to these semantics.</p>
<h1 id="transducers-aka-xforms-or-xfs">Transducers, aka xforms (or <code>xf</code>s)</h1>
<p>When using reducing functions, it’s often important (in the name of composition!) to be able to manipulate the stuff flowing into our function. I may want to filter it, or apply a fn to it, for example.</p>
<p>So, there are another class of functions called transducers, which you will see called <code>xform</code>s, or <code>xf</code>s. Their signature looks like this:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">fn</span> [rf] ...) <span class="co">;; =&gt; new-rf</span></code></pre></div>
<p>So, <code>xf</code>s manipulate <code>rf</code>s.</p>
<p>Examples of <code>xform</code>s:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">def</span><span class="fu"> xf </span>(<span class="kw">map</span> <span class="kw">inc</span>)) <span class="co">;; =&gt; an xform that `inc`s inputs before they reach the reducing function (eg: `conj`, or `str`)</span>
((xf <span class="kw">conj</span>) [] <span class="dv">1</span>) <span class="co">; =&gt; [2]</span>
((xf <span class="kw">str</span>) <span class="st">&quot;&quot;</span> <span class="dv">1</span>)  <span class="co">; =&gt; &quot;2&quot;</span></code></pre></div>
<h1 id="xform-composition">xform composition</h1>
<p>Notice how <code>xform</code>s take <code>rf</code>s and return <code>rf</code>s? We can chain them together using <code>(comp ...)</code>.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">comp</span> xf<span class="dv">-1</span> xf<span class="dv">-2</span>) <span class="co">;; =&gt; new xf</span></code></pre></div>
<p>Example of composition:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="co">;; Composition Order: top-most happens first</span>
<span class="co">;;   (that's opposite of normal fn comp, fyi. </span>
<span class="co">;;    There's a good reason for it.)</span>

(((<span class="kw">comp</span> (<span class="kw">map</span> <span class="kw">inc</span>)
        (<span class="kw">map</span> (<span class="kw">partial</span> <span class="kw">*</span> <span class="dv">2</span>)))
  <span class="kw">conj</span>) [] <span class="dv">1</span>) <span class="co">; =&gt; [4]</span>

(((<span class="kw">comp</span> (<span class="kw">map</span> (<span class="kw">partial</span> <span class="kw">*</span> <span class="dv">2</span>))
        (<span class="kw">map</span> <span class="kw">inc</span>))
   <span class="kw">conj</span>) [] <span class="dv">1</span>) <span class="co">; =&gt; [3]</span></code></pre></div>
<h1 id="and-put-em-all-together">And put em all together</h1>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">  (<span class="kw">let</span> [xform (<span class="kw">fn</span> xform [rf] ...)       <span class="co">;=&gt; new rf</span>
        rf    (<span class="kw">fn</span> rf [c x] ...)]        <span class="co">;=&gt; new c</span>
    ((xform rf) collection value)))     <span class="co">;=&gt; new c</span></code></pre></div>
<h1 id="transduce"><code>transduce</code></h1>
<p>Consider the signature of <code>reduce</code>: <code>(reduce rf collection) ; =&gt; new-collection</code></p>
<p><code>transduce</code> just adds a transducer/<code>xform</code> into the mix: <code>(transduce xform rf collection) ; =&gt; new-collection</code></p>
<p>So, transduce processes things (like a vector, or an async channel) with <code>xform</code>, and then <code>reduce</code>s them with <code>rf</code></p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">def</span><span class="fu"> xf </span>(<span class="kw">comp</span> (<span class="kw">map</span> <span class="kw">inc</span>)
              (<span class="kw">filter</span> <span class="kw">even?</span>)
              (<span class="kw">map</span> <span class="kw">str</span>)))
(transduce xf <span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;; =&gt; [&quot;2&quot; &quot;4&quot;]</span>
(transduce xf <span class="kw">str</span>  [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;; =&gt; &quot;24&quot;</span></code></pre></div>
<p>Notice, the xform says to take numbers, <code>inc</code> em, keep only <code>even?</code> ones, turn em to <code>str</code>.</p>
<p>That <em>same</em> xform works with both <code>conj</code> and <code>str</code> just fine! And it’d work great with, say, an <code>async/pipeline</code> too!</p>
<h1 id="eduction"><code>eduction</code></h1>
<p>An <code>eduction</code> basically runs a transducer over some traversable thing, like a vector:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(eduction (<span class="kw">map</span> <span class="kw">inc</span>) [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])            <span class="co">; =&gt; (2 3 4)</span>
(eduction (<span class="kw">filter</span> <span class="kw">even?</span>) (<span class="kw">range</span> <span class="dv">5</span>))     <span class="co">; =&gt; (0 2 4)</span>
(eduction (<span class="kw">comp</span> (<span class="kw">filter</span> <span class="kw">even?</span>)
                (<span class="kw">map</span> <span class="kw">inc</span>))
          (<span class="kw">range</span> <span class="dv">5</span>))                    <span class="co">; =&gt; (1 3 5)</span></code></pre></div>
<h1 id="custom-xforms-and-rfs">Custom <code>xform</code>s and <code>rf</code>s</h1>
<p>I want to leave you with a bigger example that draws from everything we just learned:</p>
<p>This transducer duplicates inputs.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [new-concat (<span class="kw">fn</span> new-concat
                   ([] [])                   <span class="co">; 0-arity</span>
                   ([c x] (<span class="kw">concat</span> c x)))     <span class="co">; 2-arity</span>
                   
      xform      (<span class="kw">fn</span> xform [rf]
                   (<span class="kw">fn</span> duplicate
                     ([] (rf))               <span class="co">; 0-arity</span>
                     ([x] x)                 <span class="co">; 1-arity</span>
                     ([c x] (rf c [x x]))))] <span class="co">; 2-arity</span>

  ((xform new-concat) [] <span class="dv">1</span>)                  <span class="co">; =&gt; (1 1)</span>
  (transduce xform new-concat (<span class="kw">range</span> <span class="dv">3</span>))     <span class="co">; =&gt; (0 0 1 1 2 2)</span>
  (eduction xform (<span class="kw">range</span> <span class="dv">3</span>)))                <span class="co">; =&gt; ([0 0] [1 1] [2 2])</span></code></pre></div>
<h1 id="arities-for-extra-credit">Arities for Extra Credit</h1>
<p>You’ll get far with what you now know. But you’ll notice in the example above the multiple arities of the transducer and the reducing function, and understanding this will round out your understanding, and allow you to write your own reducing functions and transducers.</p>
<p>The multiple arities basically completes the “plumbing” needed to make transducing work.</p>
<p>If you want something far more technical than what I’ve dissected here, I used <a href="http://hypirion.com/musings/haskell-transducers">this</a> blog post to help me figure things out.</p>
<h2 id="arities-of-rfs">Arities of <code>rf</code>s</h2>
<ul>
<li><p><strong>0-arity</strong> - <em>empty objects of the correct type</em></p>
<p>Reducing functions can declare the sort of data they work with by calling their 0-arity version:</p>
<p>eg: <code>(conj) ; =&gt; []</code> <code>(str) ; =&gt; &quot;&quot;</code></p>
<p>And <code>transduce</code> needs that information, which you can see in <em>it’s</em> 0-arity version which calls <code>(rf)</code></p></li>
<li><p><strong>1-arity</strong> - <em>completion function</em></p>
<p>This one’s a little confusing. This arity is called when the reduction is nearly complete, and allows some final work to be done.</p>
<p>Perhaps, take a look at <a href="https://github.com/clojure/clojure/blob/clojure-1.9.0-alpha14/src/clj/clojure/core.clj#L7047">partition-by</a> in the clojure core.</p>
<p>Notice the <code>let [a (java.util.ArrayList.) ...]</code> which holds state throughout the reduction. The 1-arity version of <code>partition-by</code>’s transducer pulls out the left-over state to stick it in the final return value, whereas it would have been lost otherwise.</p></li>
<li><p><strong>2-arity</strong> - <em>step function</em></p>
<p>This is the muscle of the reducing function. It is this arity version which gets passed an accumulator, and an object, and must return a new accumulator.</p></li>
</ul>
<h2 id="arities-of-xforms">Arities of <code>xform</code>s</h2>
<ul>
<li><p><strong>0-arity</strong> - <em>initial collection</em></p>
<p>This often simply calls the 0-arity version of the reducing function to get an empty object to work with.</p></li>
<li><p><strong>1-arity</strong> - <em>returns a new <code>rf</code></em></p>
<p>Here are the guts of a transducing fn - it takes an <code>rf</code> and returns a modified <code>rf</code>.</p></li>
</ul>
<h1 id="reference">Reference</h1>
<p>The following functions are related to transducers, and therefore fun to learn. I leave it as a reference since it frustrated <em>me</em> in the beginning of this academic journey to know what worked with transducers and what didn’t. This was my “bingo” card while studying them :)</p>
<pre><code>cat
completing
dedupe
distinct
drop
drop-while
eduction
filter
interpose
keep
keep-indexed
map
map-indexed
mapcat
partition-all
partition-by
random-sample
remove
replace
sequence
take
take-nth
take-while
transduce</code></pre>

                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
