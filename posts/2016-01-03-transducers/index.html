<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Transducers | growmobily</title>
        <link rel="shortcut icon" href="../../img/favicon.ico" />

        <!------ Bootstrap ----->
        
        <!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
             rel="stylesheet"
             integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
             crossorigin="anonymous">
             <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
             integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
             crossorigin="anonymous"></script>
           -->
        
        <!-- theme from: https://bootswatch.com/ -->
        <link rel="stylesheet" type="text/css" href="../../css/bootstrap.css" />

        
        <!------ FontAwesome ----->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

        <!-- My CSS -->
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    
    <body>

        <div class="banner"></div>
<br />
<div class="container">
    <div class="row">
        <div class="col-xs-8 col-xs-offset-2">

            <!-- NOTE: edit colors directly in the svg's style tag -->
            <a href="../../">
                <img class="beard" type="image/svg+xml" src="../../img/beard.svg" />
            </a>
            
        </div>
    </div>

</div>


        <div class="container">
            <div class="row">
                <div class="col-xs-8 col-xs-offset-2">
                    <div id="content">
                        <h1>Transducers</h1>
<div class="info">
    Posted on January  3, 2016
    
        by Josh
    
</div>

<p>– TODO: http://hypirion.com/musings/haskell-transducers explains the 1 arity version of reducers, esp look at <code>partitionBy</code></p>
<p><strong>TL;DR</strong> They’re not tough. Play around with the following functions in a repl, and you’ll master this super useful pattern:</p>
<p>reducing fns: <code>[conj str]</code> xform fns: <code>[(map inc) (filter even?)]</code> appliers: <code>[transduce eduction]</code></p>
<h1 id="why-transducers-composition.">Why Transducers? Composition.</h1>
<p>A good solution to a problem is one that you can easily pair with other solutions, and blissfully ignore extraneous details, such as what specifically the current solution is getting applied to.</p>
<p>This is, of course, composition. And different shapes of solutions compose in different ways. For example, plain functions compose with clojure’s <code>(comp ...)</code>.</p>
<p>ex: <code>(comp (partial + 1) (partial * 2))</code> returns a function that now acts like <code>(fn [x] (-&gt; x (* 2) (+ 1)))</code></p>
<h1 id="reducing-functions-or-rfs">Reducing Functions (or <code>rf</code>s)</h1>
<p>You’ll find over your career that a lot of solutions you write can reduce to something that looks like this:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">fn</span> reducing-fn
  [accumulator piece] ...) <span class="co">;; =&gt; new-accumulator</span></code></pre></div>
<p>Examples of reducing fns:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span>] <span class="dv">3</span>) <span class="co">;; =&gt; [1 2 3]</span>
(<span class="kw">str</span> <span class="st">&quot;accumulating string, &quot;</span> <span class="st">&quot;new piece&quot;</span>) <span class="co">;; =&gt; &quot;accumulating string, new piece&quot;</span></code></pre></div>
<p><code>reduce</code> is called <code>fold</code> in haskell, and you’ll see various flavors of <code>fold</code>, but which stay close to these semantics.</p>
<h1 id="transducers-aka-xforms-or-xfs">Transducers, aka xforms (or <code>xf</code>s)</h1>
<p>When using reducing functions, it’s often important (in the name of composition!) to be able to manipulate the stuff flowing into our function. I may want to filter it, or apply a fn to it, for example.</p>
<p>So, there are another class of functions called transducers, which you will see called <code>xform</code>s, or <code>xf</code>s. Their signature looks like this:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">fn</span> [rf] ...) <span class="co">;; =&gt; new-rf</span></code></pre></div>
<p>So, <code>xf</code>s manipulate <code>rf</code>s.</p>
<p>Examples of <code>xform</code>s:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">def</span><span class="fu"> xf </span>(<span class="kw">map</span> <span class="kw">inc</span>)) <span class="co">;; =&gt; an xform that `inc`s inputs before they reach the reducing function (eg: `conj`, or `str`)</span>
((xf <span class="kw">conj</span>) [] <span class="dv">1</span>) <span class="co">; =&gt; [2]</span>
((xf <span class="kw">str</span>) <span class="st">&quot;&quot;</span> <span class="dv">1</span>)  <span class="co">; =&gt; &quot;2&quot;</span></code></pre></div>
<h1 id="xform-composition">xform composition</h1>
<p>Notice how <code>xform</code>s take <code>rf</code>s and return <code>rf</code>s? We can chain them together using <code>(comp ...)</code>.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">comp</span> xf<span class="dv">-1</span> xf<span class="dv">-2</span>) <span class="co">;; =&gt; new xf</span></code></pre></div>
<p>Example of composition:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="co">;; Composition Order: top-most happens first</span>
<span class="co">;;   (that's opposite of normal fn comp, fyi. </span>
<span class="co">;;    There's a good reason for it.)</span>

(((<span class="kw">comp</span> (<span class="kw">map</span> <span class="kw">inc</span>)
        (<span class="kw">map</span> (<span class="kw">partial</span> <span class="kw">*</span> <span class="dv">2</span>)))
  <span class="kw">conj</span>) [] <span class="dv">1</span>) <span class="co">; =&gt; [4]</span>

(((<span class="kw">comp</span> (<span class="kw">map</span> (<span class="kw">partial</span> <span class="kw">*</span> <span class="dv">2</span>))
        (<span class="kw">map</span> <span class="kw">inc</span>))
   <span class="kw">conj</span>) [] <span class="dv">1</span>) <span class="co">; =&gt; [3]</span></code></pre></div>
<h1 id="and-put-em-all-together">And put em all together</h1>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">  (<span class="kw">let</span> [xform (<span class="kw">fn</span> xform [rf] ...)       <span class="co">;=&gt; new rf</span>
        rf    (<span class="kw">fn</span> rf [c x] ...)]        <span class="co">;=&gt; new c</span>
    ((xform rf) collection value)))     <span class="co">;=&gt; new c</span></code></pre></div>
<h1 id="transduce"><code>transduce</code></h1>
<p>Consider the signature of <code>reduce</code>: <code>(reduce rf collection) ; =&gt; new-collection</code></p>
<p><code>transduce</code> just adds a transducer/<code>xform</code> into the mix: <code>(transduce xform rf collection) ; =&gt; new-collection</code></p>
<p>So, transduce processes things (like a vector, or an async channel) with <code>xform</code>, and then <code>reduce</code>s them with <code>rf</code></p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="bu">def</span><span class="fu"> xf </span>(<span class="kw">comp</span> (<span class="kw">map</span> <span class="kw">inc</span>)
              (<span class="kw">filter</span> <span class="kw">even?</span>)
              (<span class="kw">map</span> <span class="kw">str</span>)))
(transduce xf <span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;; =&gt; [&quot;2&quot; &quot;4&quot;]</span>
(transduce xf <span class="kw">str</span>  [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;; =&gt; &quot;24&quot;</span></code></pre></div>
<p>Notice, the xform says to take numbers, <code>inc</code> em, keep only <code>even?</code> ones, turn em to <code>str</code>.</p>
<p>That <em>same</em> xform works with both <code>conj</code> and <code>str</code> just fine! And it’d work great with, say, an <code>async/pipeline</code> too!</p>
<h1 id="eduction"><code>eduction</code></h1>
<p>An <code>eduction</code> basically runs a transducer over some traversable thing, like a vector:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(eduction (<span class="kw">map</span> <span class="kw">inc</span>) [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])            <span class="co">; =&gt; (2 3 4)</span>
(eduction (<span class="kw">filter</span> <span class="kw">even?</span>) (<span class="kw">range</span> <span class="dv">5</span>))     <span class="co">; =&gt; (0 2 4)</span>
(eduction (<span class="kw">comp</span> (<span class="kw">filter</span> <span class="kw">even?</span>)
                (<span class="kw">map</span> <span class="kw">inc</span>))
          (<span class="kw">range</span> <span class="dv">5</span>))                    <span class="co">; =&gt; (1 3 5)</span></code></pre></div>
<h1 id="custom-xforms-and-rfs">Custom <code>xform</code>s and <code>rf</code>s</h1>
<p>I want to leave you with a bigger example that draws from everything we just learned:</p>
<p>The transducer duplicates inputs.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [xform      (<span class="kw">fn</span> xform [rf]
                   (<span class="kw">fn</span> duplicate            <span class="co">; the new reducing fn to return</span>
                     ([] (rf))              <span class="co">; 0-arity: returns an initial, probably empty collection</span>
                     ([x] x)                <span class="co">; 1-arity: not sure what this does</span>
                     ([c x] (rf c [x x])))) <span class="co">; 2-arity: a normal reducing function</span>
      
      new-concat (<span class="kw">fn</span> new-concat
                   ([] [])                  <span class="co">; 0-arity: returns an initial collection, needed by `transduce`</span>
                   ([c x] (<span class="kw">concat</span> c x)))]   <span class="co">; 2-arity: the guts of the fn</span>

  ((xform new-concat) [] <span class="dv">1</span>)                 <span class="co">; =&gt; (1 1)</span>
  (transduce xform new-concat (<span class="kw">range</span> <span class="dv">3</span>))    <span class="co">; =&gt; (0 0 1 1 2 2)</span>
  (eduction xform (<span class="kw">range</span> <span class="dv">3</span>)))               <span class="co">; =&gt; ([0 0] [1 1] [2 2])</span></code></pre></div>
<h1 id="arities-for-extra-credit">Arities for Extra Credit</h1>
<p>You’ll get far with what you now know. But you’ll notice in the example above the multiple arities of the transducer and the reducing function, and understanding this will round out your understanding, and allow you to write your own reducing functions and transducers.</p>
<p>The multiple arities basically completes the “plumbing” needed to make transducing work.</p>
<p>Reducing functions can declare the sort of data they work with by calling their 0-arity version:</p>
<p>eg: <code>(conj) ; =&gt; []</code> <code>(str) ; =&gt; &quot;&quot;</code></p>
<p>And <code>transduce</code> needs that information, which you can see in <em>it’s</em> 0-arity version which calls <code>(rf)</code></p>
<h1 id="reference">Reference</h1>
<p>The following functions are related to transducers, and therefore fun to learn. I leave it as a reference since it frustrated <em>me</em> in the beginning of this academic journey to know what worked with transducers and what didn’t. This was my “bingo” card while studying them :)</p>
<pre><code>cat
completing
dedupe
distinct
drop
drop-while
eduction
filter
interpose
keep
keep-indexed
map
map-indexed
mapcat
partition-all
partition-by
random-sample
remove
replace
sequence
take
take-nth
take-while
transduce</code></pre>

                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
